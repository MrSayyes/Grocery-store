# JVM虚拟机

## 一、类加载机制

- 启动类加载器

- 扩展类加载器
- 应用程序类加载器
- 自定义类加载器

> 双亲委派（父类加载的不给子类加载、一个类加载一次）
>
> 沙箱安全（委派保证安全）

### 第一步：加载

1）获取二进制字节流

2）静态存储结构转换为方法区的运行时数据结构

3）在java堆里面生成一个类对象，作为方法区访问入口

### 第二步：验证

1）验证Class文件的标识：魔数Magic Number

2）验证版本号

3）验证常量池

4）验证Class文件的每个部分（字段表、方法表等）

5）元数据验证（父类验证、继承验证、final验证）

6）字节码验证（指令验证）

7）符号引用验证（通过符号引用是否能找到字段、方法、类）

### 第三步：准备

1）分配内存变量并设置类变量的初始化阶段

2）只对static类变量进行内存分配

> static int n=1；
>
> 初始化值是0，而不是1，因为还没有执行任何java方法
>
> static final int n=1；
>
> 对应常量池ConstantValue，在准备阶段n必须被赋值成1；

### 第四步：解析

1）符号引用解析（符号引用->直接引用）

> 直接引用：指向目标的指针或者偏移量
>
> 符号引用->直接引用：
>
> 主要涉及：类、接口、字段、方法（接口、类）等

2）字段解析

3）类方法解析

4）接口方法解析

### 第五步：初始化

> clinit静态变量、静态块的初始化
>
> init类的初始化
>
> Class A{
>
> ​	static int i=2;//静态变量
>
> ​	static {
>
> ​		//处理
>
> ​	}
>
> ​	int n;//实例变量
>
> }

## 二、字节码执行机制

> java一开始是解释执行，后面出现JIT编译执行，故是混合执行

- 输入字节码文件
- 处理过程是字节码解释的过程
- 输出的是执行结果

## 三、JVM内存模型

- 方法区（类信息、常量、静态变量、即时编译器编译后的代码）
- 堆
- java栈（最小配置108k，默认1M；栈帧：局部变量表[数据基本类型、引用]、操作数栈、动态连接）
- 本地方法栈（调用c/c++库）
- 程序计数器（下一条指令地址）
- 类加载器
- 执行引擎

## 四、GC垃圾回收

1、对堆、方法区进行回收

2、分代收集算法

- 引用计数

- 复制算法（年轻代）
- 标记清除（老年代）
- 标记整理

3、默认垃圾回收器

- jdk1.7/1.8：Parallel Scavenge（新生代）+Paralled Old
- jdk1.9：G1

```
垃圾回收器：
1、Serial收集器：适用用户的桌面级场景
2、ParNew收集器：适用server首选的新生代收集器
3、Parallel Scavenge收集器：适用后台计算不需要太多交互
新生代》》》》老年代
4、Concurrent Mark Sweep收集器：适用互联网站或web服务器
5、Serial Old
6、Paralled Old收集器
新生代《《》》老生代
7、G1收集器（在jdk1.9）
```

可以组合关系

Serial->CMS、Serial Old

ParNew->CMS、Serial Old、Paralled Old

Parallel Scavenge->Paralled Old

4、内存分配

- 对象首先进入Eden区，大对象直接进入老年代

> 新生代：Eden+s0+s1=Xmn
>
> 问题：-Xmn 100m -XX:SurvivorRatio=8，请问Eden区多大？
>
> 解：Eden：s0：s1 = SurvivorRatio：1：1，即100*（8/（8+1+1））
>
> 调优考虑少触发Full GC，尽可能的在Minor GC完成回收（新生代内存：老年代内存=1：2）

- 根据存活判断，默认存活15次进入老年代

## 五、JVM性能监控与故障定位

> jdk附带工具

### 1、jinfo：配置信息工具

### 2、jstat：统计信息监控工具

> Case:类加载统计、编译统计、垃圾回收统计

```
用法：jstat [-命令选项][vmid][间隔时间][查询次数]
命令选项：
-class
-compiler
-gcutil
-gccause
其他都是成对出现
-gc*
-gc*capacity
```

### 3、jmap：内存映像工具

> Case:映射对快照、抓取堆内存

```
用法：jmap [-命令选项][vmid]
命令选项：
-dump
-histo
-permstat
-heap
-finalizerinfo
-F
```

对于其中指令产生的hprof文件需要**MAT**的Eclipse工具可以分析内存情况。

### 4、jstack：栈堆异常跟踪工具

```
用法：jstack [-命令选项][vmid]
命令选项：
-F
-l
-m
```

### 5、jconsole监控工具

### 6、jvisualvm（jconsole的升级版本）

## 六、JVM调优

### 1、合理编程

1）非堆内存处理

- 堆外内存
- 文件句柄
- Socket句柄
- 数据库连接

```
文件：
限制文件大小，异步方式

网络IO：
限流

大对象：
对于JVM绝对是一个噩梦
避免使用大对象，尽量减少大对象的生存时间
```

### 2、充分并合理的使用硬件资源

JDK32位版本尽量使用32版本，内存最高可以使用4G

### 3、合理地进行JVM调优

- 降低Full GC的频次，一天1-2次，控制在晚上，重启服务器或定时触发Full GC

- 确保大多数对象“朝生夕死”

- 堆高大对象进入老年代的门槛（-XX:MaxTenuringThreshold=15）

垃圾回收器的选择可以提高效率！！！

JVM初始分配的堆内存由-Xms指定，默认是物理内存的1/64；JVM最大分配的堆内存由-Xmx指定，默认是物理内存的1/4

```
常用配置的参数：
-Xmn:新生代内存大小
-Xms:堆初始化内存大小
-Xmx:堆允许的最大内存大小
PermSize:初始化分配的非堆内存
MaxPermSize:允许分配的最大非堆内存
SurvivorRatio=n:新生代eden区与幸存者区的比例值
UserConcMarkSweepGC:垃圾回收器，这里是CMS回收器
HeapDumpOnOutOfMemoryError:oom异常时记录异常日志
-Xloggc:[路径]记录文件
PrintGCDetails:打印gc日志
```

## 七、cpu内存过高如何查看问题

> 结合linux和jdk命令一块分析

第一步：先top查看cpu占比最高的进程

第二步：ps -ef 或 jps进一步定位，得知是一个怎么样的一个后台程序

第三步：==**定位到具体线程或者代码**==

```
#查看cpu占用高的进程有哪些线程，cpu高的tid
ps -mp 进程 -o THREAD,tid,time
```

第四步：将需要的线程ID转换为16进制格式（英文小写格式）

```
#指令转换进制
printf "%x\n" 有问题的线程ID
#若不会指令就计算器计算
```

第五步：jstack 进程ID | grep tid(16进制线程id小写英文) -A60

> 如：进程为5000的线程100的指令查看，-A60是查看前60行
>
> jstack 5000 | grep 100 -A60